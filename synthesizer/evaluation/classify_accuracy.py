"""
Calculate accuracy from gen_classification, gt_classification, true_labels
 + default: 'true_label' from audio name, which stored in gt & gen files
 + --true-from-file: load from id.path, according `id` items in gt & gen files

-----
Usage:

python code/synthesis/evaluation/classify_accuracy.py

"""


import os
import re
import json
import argparse
from pathlib import Path

import pandas as pd
from sklearn import metrics


with open("/data/haoqiuyan/describe_speech/framework/meld/id_paths.txt", 'r') as af:
    pathsL = [line.strip() for line in af]
# 8 --> 20
with open("/data/haoqiuyan/describe_speech/framework/synthesis/ours/audios/replace_dict_labels_8-20.json", 'r') as cf:
        replaceD = json.load(cf)
# 20 --> 8
# with open("/data/haoqiuyan/describe_speech/framework/synthesis/ours/audios/replace_dict_labels_20-8.json", 'r') as cf:
#         replaceD = json.load(cf)


def read_classification_file(file):
    readDF = pd.read_csv(file, header=0, delimiter='\t')

    return readDF



def cal_accuracy(ref, syn):
    assert len(ref) == len(
            syn
        ), f"mismatch between number of audios and labels ({len(ref)} vs {len(syn)})"
    correct = sum(label == pred for label, pred in zip(ref, syn))
    accuracy = correct / len(ref)
    # print(f"Accuracy: {100*accuracy:.2f} % ({correct}/{len(ref)} correct)")

    return accuracy


def get_emotion_from_path(audiopath):
    """audiopath: generated by vocoder
    ex04-ex02_angry_003-ex02_angry_css003_ex02_angry_high_fast_high_gt.wav"""
    name = os.path.basename(audiopath)
    return name.split('_')[-5]


def get_emotion_from_path_pretrain(audiopath):
    """audiopath: generated by vocoder (pretrained)
    p299_326_mic1_vctk_p299_default_gen.wav,
    ex03_enunciated_00354_ex03_enunciated_gen.wav"""
    name = os.path.basename(audiopath)
    return name.split('_')[-2]


def get_emotion_from_path_idpath(audiopath):
    """audiopath: original audioname (finetuned)
    test-dia34_utt8-Monica-neutral.wav"""
    name = os.path.basename(audiopath)
    return name.split('.')[0].split('-')[-1]


def get_audioname_from_path_gt(path):
    """name: 80.mp3"""
    id = os.path.basename(path).split('.')[0]
    return pathsL[int(id)-1]


def get_audioname_from_path_gen(path):
    """name: 598_<built-in function id>_ex01_happy_high_fast_high_gen.wav"""
    id = os.path.basename(path).split('_')[0]
    return pathsL[int(id)-1]


def cal_accuracy_groupby(df, label):
    accDF = df.groupby(label).apply(lambda x: metrics.accuracy_score(x['true_label'], x[label]))
    return accDF.reset_index(name="accuracy")


def find_expresso_read(path):
    expresso = re.search("ex", os.path.basename(path))
    conv = re.search("-", os.path.basename(path))
    if expresso and not conv:
        return 1
    else: 
        return 0
    

def find_expresso_conv(path):
    expresso = re.search("ex", os.path.basename(path))
    conv = re.search("-", os.path.basename(path))
    if expresso and conv:
        return 1
    else: 
        return 0


def cal_accuracy(mergedDF, name):
    trueS, genS, gtS = mergedDF['true_label'].tolist(), mergedDF['gen_label'].tolist(), mergedDF['gt_label'].tolist()
    gen_trueS, gt_trueS = trueS, trueS

    true_gen = metrics.accuracy_score(gt_trueS, gtS)
    gt_gen = metrics.accuracy_score(gen_trueS, genS)
    print(f">>>Accuracy [{name}]\nTrue & gt: {true_gen}\nTrue & gen: {gt_gen}\n")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--gen-file", required=True, type=Path, help="labels of generated"
    )
    parser.add_argument(
        "--gt-file", required=True, type=Path
    )
    parser.add_argument(
        "--true-from-file", action="store_true", help="true label read from id_path file"
    )
    parser.add_argument(
        "--gen-by-pretrain", action="store_true", help="doing evaluation on pretrained model"
    )
    
    args = parser.parse_args()

    # gen_file = "speech_synthesis/evaluation/dev/gen_classification.txt"
    # gt_file = "speech_synthesis/evaluation/dev/gt_classification.txt"
    genDF = read_classification_file(args.gen_file)
    gtDF = read_classification_file(args.gt_file)
    genDF = genDF.rename(columns={'prediction': 'gen_label'})
    gtDF = gtDF.rename(columns={'prediction': 'gt_label'})
    # gen.wav --> gt.wav
    genDF['audio'] = genDF['audio'].apply(lambda x:x.replace("gen.wav", "gt.wav"))

    if args.true_from_file:
        genDF['true_audioname'] = genDF['audio'].map(get_audioname_from_path_gen)
        genDF['true_label'] = genDF['true_audioname'].map(get_emotion_from_path_idpath)
        gtDF['true_audioname'] = gtDF['audio'].map(get_audioname_from_path_gt)
        gtDF['true_label'] = gtDF['true_audioname'].map(get_emotion_from_path_idpath)

        # true_label is different with classifier labels
        # 8 --> 20
        genDF['true_label'] = genDF.true_label.replace(replaceD)
        gtDF['true_label'] = gtDF.true_label.replace(replaceD)
        # 20 --> 8
        # genDF['gen_label'] = genDF.gen_label.replace(replaceD)
        # gtDF['gt_label'] = gtDF.gt_label.replace(replaceD)
        
        
        genS, gtS = genDF['gen_label'].tolist(), gtDF['gt_label'].tolist()
        # different samples
        gen_trueS, gt_trueS = genDF['true_label'].tolist(), gtDF['true_label'].tolist()

        true_gen = metrics.accuracy_score(gt_trueS, gtS)
        gt_gen = metrics.accuracy_score(gen_trueS, genS)
        print(f">>>Accuracy\nTrue & gt: {true_gen}\nTrue & gen: {gt_gen}\n")

        print(">>>Value Counts\nTrue & gt:\ngt-true {}\ngt {}\nTrue & gen: \ngen-true {}\ngen {}".format(\
            gtDF["true_label"].value_counts(), gtDF["gt_label"].value_counts(), \
            genDF["true_label"].value_counts(), genDF["gen_label"].value_counts(), \
            )
        )
        
    else:
        if args.gen_by_pretrain:
            gtDF['true_label'] = gtDF['audio'].apply(get_emotion_from_path_pretrain)
        else:
            gtDF['true_label'] = gtDF['audio'].apply(get_emotion_from_path)

        mergedDF = gtDF.set_index('audio').join(genDF.set_index('audio'))
        # 有些audio生成失败,即gen rows < gt rows
        mergedDF = mergedDF.fillna(-1)
        # 把expresso read和conv样本分开
        mergedDF['is_read'] = mergedDF.index.map(find_expresso_read)
        mergedDF['is_conv'] = mergedDF.index.map(find_expresso_conv)

        readDF = mergedDF[mergedDF['is_read']==1]
        convDF = mergedDF[mergedDF['is_conv']==1]

        cal_accuracy(readDF, name="expresso read")
        cal_accuracy(convDF, name="expresso conversation")

    # true_gen = metrics.accuracy_score(trueS, genS)
    # gt_gen = metrics.accuracy_score(gtS, genS)
    
        print(">>>Value Counts\nTrue & gt:\ngt-true {}\ngt {}\nTrue & gen: \ngen-true {}\ngen {}".format(\
            gtDF["true_label"].value_counts(), gtDF["gt_label"].value_counts(), \
            "Same as above", genDF["gen_label"].value_counts(), \
            )
        )

    # gen_acc_groupy = cal_accuracy_groupby(genDF, 'gen_label')
    # gt_acc_groupy = cal_accuracy_groupby(gtDF, 'gt_label')
    # print(f">>>Groupby Accuracy\nTrue & gt: {gt_acc_groupy}\nTrue & gen: {gen_acc_groupy}\n")
    


if __name__ == '__main__':
    main()